import { AppState, PresetKey } from '@/types';
import { PRNG_CODE } from './prng';

// Generate the self-contained component code
export function generateExportCode(state: AppState): string {
  const presetCode = getPresetCode(state);

  return `/**
 * TitleMotion - Generated by Title Motion Lab
 *
 * Usage:
 *   import { TitleMotion } from './TitleMotion';
 *
 *   // Use with default text
 *   <TitleMotion />
 *
 *   // Use with custom text
 *   <TitleMotion text="Your Custom Title" />
 *
 *   // Control playback
 *   <TitleMotion play={isPlaying} onComplete={() => console.log('done')} />
 *
 * Dependencies: framer-motion
 *   npm install framer-motion
 */

'use client';

import { useState, useEffect, useRef, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

// Seeded PRNG for deterministic randomness
${PRNG_CODE}

// Configuration
const CONFIG = {
  text: ${JSON.stringify(state.text)},
  preset: ${JSON.stringify(state.preset)},
  duration: ${state.global.duration},
  stagger: ${state.global.stagger},
  delay: ${state.global.delay},
  seed: ${state.global.seed},
  // Typography
  fontFamily: ${JSON.stringify(getFontStack(state.typography.fontFamily))},
  fontSize: ${state.global.duration},
  fontWeight: ${state.typography.fontWeight},
  letterSpacing: '${state.typography.letterSpacing}em',
  lineHeight: ${state.typography.lineHeight},
  textTransform: ${JSON.stringify(state.typography.textTransform)},
};

interface TitleMotionProps {
  text?: string;
  className?: string;
  style?: React.CSSProperties;
  play?: boolean;
  onComplete?: () => void;
}

${presetCode}
`;
}

function getFontStack(fontFamily: string): string {
  switch (fontFamily) {
    case 'inter':
      return 'Inter, system-ui, sans-serif';
    case 'playfair':
      return '"Playfair Display", Georgia, serif';
    case 'spaceMono':
      return '"Space Mono", monospace';
    default:
      return 'system-ui, sans-serif';
  }
}

function getPresetCode(state: AppState): string {
  switch (state.preset) {
    case 'scramble':
      return generateScrambleCode(state);
    case 'blur':
      return generateBlurCode(state);
    case 'roller':
      return generateRollerCode(state);
    case 'wordSlideUp':
      return generateWordSlideUpCode(state);
    case 'charPop':
      return generateCharPopCode(state);
    case 'maskWipe':
      return generateMaskWipeCode(state);
    case 'underlineWipe':
      return generateUnderlineWipeCode(state);
    case 'glitchSlice':
      return generateGlitchSliceCode(state);
    case 'particleBurst':
      return generateParticleBurstCode(state);
    case 'sparkleTrail':
      return generateSparkleTrailCode(state);
    default:
      return generateScrambleCode(state);
  }
}

function generateScrambleCode(state: AppState): string {
  const s = state.scramble;
  const charset = s.charsetMode === 'special'
    ? '!@#$%^&*()_+-=[]{}|;:,.<>?/~`'
    : 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?/~`';

  return `// Scramble preset settings
const SCRAMBLE_CONFIG = {
  charset: ${JSON.stringify(charset)},
  intensity: ${s.intensity},
  steps: ${s.steps},
  revealMode: ${JSON.stringify(s.revealMode)},
  preserveSpaces: ${s.preserveSpaces},
  preservePunctuation: ${s.preservePunctuation},
};

const PUNCTUATION = new Set(['.', ',', '!', '?', ';', ':', "'", '"', '-']);

function generateRevealOrder(length: number, mode: string, seed: number): number[] {
  const indices = Array.from({ length }, (_, i) => i);
  switch (mode) {
    case 'ltr': return indices;
    case 'rtl': return [...indices].reverse();
    case 'center': {
      const center = Math.floor(length / 2);
      const result = [center];
      for (let offset = 1; result.length < length; offset++) {
        if (center - offset >= 0) result.push(center - offset);
        if (center + offset < length) result.push(center + offset);
      }
      return result;
    }
    case 'random': {
      const random = createPRNG(seed + 12345);
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }
      return indices;
    }
    default: return indices;
  }
}

export function TitleMotion({
  text = CONFIG.text,
  className = '',
  style = {},
  play = true,
  onComplete,
}: TitleMotionProps) {
  const chars = useMemo(() => Array.from(text), [text]);
  const revealOrder = useMemo(
    () => generateRevealOrder(chars.length, SCRAMBLE_CONFIG.revealMode, CONFIG.seed),
    [chars.length]
  );

  const getInitialStates = () => {
    const initRandom = createPRNG(CONFIG.seed);
    const charsetArr = SCRAMBLE_CONFIG.charset.split('');
    return chars.map((char, index) => {
      const isSpace = char === ' ';
      const isPunct = PUNCTUATION.has(char);
      const preserve = (SCRAMBLE_CONFIG.preserveSpaces && isSpace) ||
                       (SCRAMBLE_CONFIG.preservePunctuation && isPunct);
      return {
        target: char,
        current: preserve ? char : charsetArr[Math.floor(initRandom() * charsetArr.length)],
        isRevealed: preserve,
        revealOrder: revealOrder.indexOf(index),
      };
    });
  };

  const [charStates, setCharStates] = useState(getInitialStates);
  const tickRef = useRef(0);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (!play) return;

    tickRef.current = 0;
    setCharStates(getInitialStates());
    const tickInterval = CONFIG.duration / SCRAMBLE_CONFIG.steps;

    const delayTimeout = setTimeout(() => {
      intervalRef.current = setInterval(() => {
        tickRef.current++;
        const currentTick = tickRef.current;
        const totalTicks = SCRAMBLE_CONFIG.steps;

        setCharStates(prev => {
          const tickRandom = createPRNG(CONFIG.seed + currentTick * 1000);
          const charsetArr = SCRAMBLE_CONFIG.charset.split('');

          const newStates = prev.map((state) => {
            if (state.isRevealed) return state;
            const revealThreshold = (state.revealOrder / chars.length) * totalTicks * SCRAMBLE_CONFIG.intensity;
            const shouldReveal = currentTick >= revealThreshold + (totalTicks * (1 - SCRAMBLE_CONFIG.intensity));

            if (shouldReveal) {
              return { ...state, current: state.target, isRevealed: true };
            }
            return { ...state, current: charsetArr[Math.floor(tickRandom() * charsetArr.length)] };
          });

          if (newStates.every(s => s.isRevealed)) {
            if (intervalRef.current) clearInterval(intervalRef.current);
            setTimeout(() => onComplete?.(), 50);
          }
          return newStates;
        });
      }, tickInterval);
    }, CONFIG.delay);

    return () => {
      clearTimeout(delayTimeout);
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [play, text]);

  return (
    <span
      className={className}
      style={{
        display: 'inline-flex',
        flexWrap: 'wrap',
        fontFamily: CONFIG.fontFamily,
        fontWeight: CONFIG.fontWeight,
        letterSpacing: CONFIG.letterSpacing,
        lineHeight: CONFIG.lineHeight,
        textTransform: CONFIG.textTransform as any,
        ...style,
      }}
    >
      {charStates.map((state, index) => (
        <motion.span
          key={index}
          initial={{ opacity: 0.6 }}
          animate={{ opacity: state.isRevealed ? 1 : 0.7 }}
          transition={{ duration: 0.1 }}
          style={{
            display: 'inline-block',
            whiteSpace: 'pre',
            minWidth: state.target === ' ' ? '0.25em' : undefined,
          }}
        >
          {state.current}
        </motion.span>
      ))}
    </span>
  );
}`;
}

function generateBlurCode(state: AppState): string {
  const s = state.blur;
  return `// Blur reveal preset settings
const BLUR_CONFIG = {
  startBlur: ${s.startBlur},
  startOpacity: ${s.startOpacity},
  yOffset: ${s.yOffset},
  overshoot: ${s.overshoot},
  unit: ${JSON.stringify(s.unit)},
};

function splitText(text: string) {
  const chars = Array.from(text);
  const words: string[] = [];
  let current = '';
  for (const char of chars) {
    if (char === ' ') {
      if (current) words.push(current);
      words.push(' ');
      current = '';
    } else {
      current += char;
    }
  }
  if (current) words.push(current);
  return { chars, words };
}

export function TitleMotion({
  text = CONFIG.text,
  className = '',
  style = {},
  play = true,
  onComplete,
}: TitleMotionProps) {
  const { chars, words } = useMemo(() => splitText(text), [text]);
  const [key, setKey] = useState(0);

  useEffect(() => {
    if (play) setKey(k => k + 1);
  }, [play]);

  const getVariants = (index: number) => {
    const staggerDelay = (index * CONFIG.stagger) / 1000;
    const baseDuration = CONFIG.duration / 1000;

    return {
      hidden: {
        filter: \`blur(\${BLUR_CONFIG.startBlur}px)\`,
        opacity: BLUR_CONFIG.startOpacity,
        y: BLUR_CONFIG.yOffset,
      },
      visible: {
        filter: 'blur(0px)',
        opacity: 1,
        y: 0,
        transition: BLUR_CONFIG.overshoot
          ? { type: 'spring', stiffness: 100, damping: 10, delay: (CONFIG.delay / 1000) + staggerDelay }
          : { duration: baseDuration, delay: (CONFIG.delay / 1000) + staggerDelay, ease: [0, 0, 0.2, 1] },
      },
    };
  };

  const items = BLUR_CONFIG.unit === 'char' ? chars : BLUR_CONFIG.unit === 'word' ? words : [text];

  return (
    <span
      className={className}
      style={{
        display: 'inline-flex',
        flexWrap: 'wrap',
        fontFamily: CONFIG.fontFamily,
        fontWeight: CONFIG.fontWeight,
        letterSpacing: CONFIG.letterSpacing,
        lineHeight: CONFIG.lineHeight,
        textTransform: CONFIG.textTransform as any,
        ...style,
      }}
    >
      {items.map((item, index) => (
        <motion.span
          key={\`\${key}-\${index}\`}
          variants={getVariants(index)}
          initial="hidden"
          animate={play ? 'visible' : 'hidden'}
          onAnimationComplete={index === items.length - 1 ? onComplete : undefined}
          style={{
            display: 'inline-block',
            whiteSpace: 'pre',
            minWidth: item === ' ' ? '0.25em' : undefined,
          }}
        >
          {item}
        </motion.span>
      ))}
    </span>
  );
}`;
}

function generateRollerCode(state: AppState): string {
  const s = state.roller;
  const alphabets: Record<string, string> = {
    uppercase: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
    lowercase: 'abcdefghijklmnopqrstuvwxyz',
    numbers: '0123456789',
    full: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
  };

  return `// Roller board preset settings
const ROLLER_CONFIG = {
  alphabet: ${JSON.stringify(alphabets[s.alphabet])},
  spins: ${s.spins},
  spinRandomness: ${s.spinRandomness},
  direction: ${JSON.stringify(s.direction)},
};

export function TitleMotion({
  text = CONFIG.text,
  className = '',
  style = {},
  play = true,
  onComplete,
}: TitleMotionProps) {
  const chars = useMemo(() => Array.from(text), [text]);
  const completedRef = useRef(0);
  const [key, setKey] = useState(0);

  useEffect(() => {
    if (play) {
      completedRef.current = 0;
      setKey(k => k + 1);
    }
  }, [play]);

  const columns = useMemo(() => {
    const random = createPRNG(CONFIG.seed);
    const alphabetChars = ROLLER_CONFIG.alphabet.split('');

    return chars.map((char) => {
      if (char === ' ') return { target: ' ', stack: [' '], spins: 0 };

      const baseSpins = ROLLER_CONFIG.spins;
      const randomOffset = Math.floor(random() * ROLLER_CONFIG.spinRandomness * baseSpins * 2) - (ROLLER_CONFIG.spinRandomness * baseSpins);
      const actualSpins = Math.max(1, Math.round(baseSpins + randomOffset));

      const stack: string[] = [];
      for (let spin = 0; spin < actualSpins; spin++) {
        const shuffled = [...alphabetChars];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        stack.push(...shuffled);
      }
      stack.push(char);
      return { target: char, stack, spins: actualSpins };
    });
  }, [chars]);

  const maxStackLength = Math.max(...columns.map(c => c.stack.length));
  const charHeight = 1.2;

  const handleComplete = () => {
    completedRef.current++;
    if (completedRef.current === chars.length) onComplete?.();
  };

  return (
    <span
      className={className}
      style={{
        display: 'inline-flex',
        fontFamily: CONFIG.fontFamily,
        fontWeight: CONFIG.fontWeight,
        letterSpacing: CONFIG.letterSpacing,
        lineHeight: CONFIG.lineHeight,
        textTransform: CONFIG.textTransform as any,
        ...style,
      }}
    >
      {columns.map((column, index) => {
        if (column.target === ' ') {
          return <span key={\`\${key}-\${index}\`} style={{ display: 'inline-block', width: '0.3em' }}>&nbsp;</span>;
        }

        const stackLength = column.stack.length;
        const duration = (stackLength / maxStackLength) * (CONFIG.duration / 1000);
        const delay = (CONFIG.delay / 1000) + (index * CONFIG.stagger / 1000);
        const finalY = ROLLER_CONFIG.direction === 'up' ? -(stackLength - 1) * charHeight : 0;
        const initialY = ROLLER_CONFIG.direction === 'up' ? 0 : -(stackLength - 1) * charHeight;

        return (
          <span
            key={\`\${key}-\${index}\`}
            style={{ display: 'inline-block', position: 'relative', overflow: 'hidden', height: \`\${charHeight}em\` }}
          >
            <motion.span
              style={{ display: 'inline-flex', flexDirection: 'column', position: 'absolute', left: 0, top: 0 }}
              initial={{ y: \`\${initialY}em\` }}
              animate={play ? { y: \`\${finalY}em\` } : { y: \`\${initialY}em\` }}
              transition={{ duration, delay, ease: [0.25, 0.1, 0.25, 1] }}
              onAnimationComplete={handleComplete}
            >
              {column.stack.map((char, charIndex) => (
                <span key={charIndex} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: \`\${charHeight}em\` }}>
                  {char}
                </span>
              ))}
            </motion.span>
          </span>
        );
      })}
    </span>
  );
}`;
}

function generateWordSlideUpCode(state: AppState): string {
  const s = state.wordSlideUp;
  return `// Word slide up preset settings
const SLIDE_CONFIG = {
  yDistance: ${s.yDistance},
  overshoot: ${s.overshoot},
};

function splitText(text: string) {
  const words: string[] = [];
  let current = '';
  for (const char of Array.from(text)) {
    if (char === ' ') {
      if (current) words.push(current);
      words.push(' ');
      current = '';
    } else {
      current += char;
    }
  }
  if (current) words.push(current);
  return words;
}

export function TitleMotion({
  text = CONFIG.text,
  className = '',
  style = {},
  play = true,
  onComplete,
}: TitleMotionProps) {
  const words = useMemo(() => splitText(text), [text]);
  const [key, setKey] = useState(0);

  useEffect(() => {
    if (play) setKey(k => k + 1);
  }, [play]);

  const getVariants = (index: number) => {
    const staggerDelay = (index * CONFIG.stagger) / 1000;
    if (SLIDE_CONFIG.overshoot) {
      return {
        hidden: { y: SLIDE_CONFIG.yDistance, opacity: 0 },
        visible: {
          y: 0, opacity: 1,
          transition: { type: 'spring', stiffness: 200, damping: 20, delay: (CONFIG.delay / 1000) + staggerDelay },
        },
      };
    }
    return {
      hidden: { y: SLIDE_CONFIG.yDistance, opacity: 0 },
      visible: {
        y: 0, opacity: 1,
        transition: { duration: CONFIG.duration / 1000, delay: (CONFIG.delay / 1000) + staggerDelay, ease: [0, 0, 0.2, 1] },
      },
    };
  };

  const nonSpaceWords = words.filter(w => w !== ' ');
  const lastIndex = words.lastIndexOf(nonSpaceWords[nonSpaceWords.length - 1]);

  return (
    <span
      className={className}
      style={{
        display: 'inline-flex',
        flexWrap: 'wrap',
        overflow: 'hidden',
        fontFamily: CONFIG.fontFamily,
        fontWeight: CONFIG.fontWeight,
        letterSpacing: CONFIG.letterSpacing,
        lineHeight: CONFIG.lineHeight,
        textTransform: CONFIG.textTransform as any,
        ...style,
      }}
    >
      {words.map((word, index) => {
        if (word === ' ') return <span key={\`\${key}-\${index}\`} style={{ display: 'inline-block', whiteSpace: 'pre' }}>{word}</span>;
        return (
          <motion.span
            key={\`\${key}-\${index}\`}
            variants={getVariants(index)}
            initial="hidden"
            animate={play ? 'visible' : 'hidden'}
            onAnimationComplete={index === lastIndex ? onComplete : undefined}
            style={{ display: 'inline-block' }}
          >
            {word}
          </motion.span>
        );
      })}
    </span>
  );
}`;
}

function generateCharPopCode(state: AppState): string {
  const s = state.charPop;
  return `// Char pop preset settings
const POP_CONFIG = {
  startScale: ${s.startScale},
  springStiffness: ${s.springStiffness},
};

export function TitleMotion({
  text = CONFIG.text,
  className = '',
  style = {},
  play = true,
  onComplete,
}: TitleMotionProps) {
  const chars = useMemo(() => Array.from(text), [text]);
  const [key, setKey] = useState(0);

  useEffect(() => {
    if (play) setKey(k => k + 1);
  }, [play]);

  const getVariants = (index: number) => ({
    hidden: { scale: POP_CONFIG.startScale, opacity: 0 },
    visible: {
      scale: 1, opacity: 1,
      transition: { type: 'spring', stiffness: POP_CONFIG.springStiffness, damping: 15, delay: (CONFIG.delay / 1000) + (index * CONFIG.stagger / 1000) },
    },
  });

  return (
    <span
      className={className}
      style={{
        display: 'inline-flex',
        flexWrap: 'wrap',
        fontFamily: CONFIG.fontFamily,
        fontWeight: CONFIG.fontWeight,
        letterSpacing: CONFIG.letterSpacing,
        lineHeight: CONFIG.lineHeight,
        textTransform: CONFIG.textTransform as any,
        ...style,
      }}
    >
      {chars.map((char, index) => {
        if (char === ' ') return <span key={\`\${key}-\${index}\`} style={{ display: 'inline-block', width: '0.25em' }}>&nbsp;</span>;
        return (
          <motion.span
            key={\`\${key}-\${index}\`}
            variants={getVariants(index)}
            initial="hidden"
            animate={play ? 'visible' : 'hidden'}
            onAnimationComplete={index === chars.length - 1 ? onComplete : undefined}
            style={{ display: 'inline-block', transformOrigin: 'center' }}
          >
            {char}
          </motion.span>
        );
      })}
    </span>
  );
}`;
}

function generateMaskWipeCode(state: AppState): string {
  const s = state.maskWipe;
  return `// Mask wipe preset settings
const MASK_CONFIG = {
  direction: ${JSON.stringify(s.direction)},
  unit: ${JSON.stringify(s.unit)},
};

function getClipPath(direction: string, progress: 'start' | 'end') {
  if (progress === 'start') {
    switch (direction) {
      case 'left': return 'inset(0 100% 0 0)';
      case 'right': return 'inset(0 0 0 100%)';
      case 'up': return 'inset(100% 0 0 0)';
      case 'down': return 'inset(0 0 100% 0)';
      default: return 'inset(0 100% 0 0)';
    }
  }
  return 'inset(0 0 0 0)';
}

function splitText(text: string) {
  const words: string[] = [];
  let current = '';
  for (const char of Array.from(text)) {
    if (char === ' ') {
      if (current) words.push(current);
      words.push(' ');
      current = '';
    } else {
      current += char;
    }
  }
  if (current) words.push(current);
  return words;
}

export function TitleMotion({
  text = CONFIG.text,
  className = '',
  style = {},
  play = true,
  onComplete,
}: TitleMotionProps) {
  const words = useMemo(() => splitText(text), [text]);
  const [key, setKey] = useState(0);

  useEffect(() => {
    if (play) setKey(k => k + 1);
  }, [play]);

  const getVariants = (index: number) => ({
    hidden: { clipPath: getClipPath(MASK_CONFIG.direction, 'start') },
    visible: {
      clipPath: getClipPath(MASK_CONFIG.direction, 'end'),
      transition: { duration: CONFIG.duration / 1000, delay: (CONFIG.delay / 1000) + (index * CONFIG.stagger / 1000), ease: [0.4, 0, 0.2, 1] },
    },
  });

  if (MASK_CONFIG.unit === 'line') {
    return (
      <motion.span
        key={key}
        className={className}
        variants={getVariants(0)}
        initial="hidden"
        animate={play ? 'visible' : 'hidden'}
        onAnimationComplete={onComplete}
        style={{
          display: 'inline-block',
          fontFamily: CONFIG.fontFamily,
          fontWeight: CONFIG.fontWeight,
          letterSpacing: CONFIG.letterSpacing,
          lineHeight: CONFIG.lineHeight,
          textTransform: CONFIG.textTransform as any,
          ...style,
        }}
      >
        {text}
      </motion.span>
    );
  }

  const nonSpaceWords = words.filter(w => w !== ' ');
  const lastIndex = words.lastIndexOf(nonSpaceWords[nonSpaceWords.length - 1]);

  return (
    <span
      className={className}
      style={{
        display: 'inline-flex',
        flexWrap: 'wrap',
        fontFamily: CONFIG.fontFamily,
        fontWeight: CONFIG.fontWeight,
        letterSpacing: CONFIG.letterSpacing,
        lineHeight: CONFIG.lineHeight,
        textTransform: CONFIG.textTransform as any,
        ...style,
      }}
    >
      {words.map((word, index) => {
        if (word === ' ') return <span key={\`\${key}-\${index}\`} style={{ display: 'inline-block', whiteSpace: 'pre' }}>{word}</span>;
        return (
          <motion.span
            key={\`\${key}-\${index}\`}
            variants={getVariants(index)}
            initial="hidden"
            animate={play ? 'visible' : 'hidden'}
            onAnimationComplete={index === lastIndex ? onComplete : undefined}
            style={{ display: 'inline-block' }}
          >
            {word}
          </motion.span>
        );
      })}
    </span>
  );
}`;
}

function generateUnderlineWipeCode(state: AppState): string {
  const s = state.underlineWipe;
  return `// Underline wipe preset settings
const UNDERLINE_CONFIG = {
  underlineColor: ${JSON.stringify(s.underlineColor)},
  thickness: ${s.thickness},
  phaseOverlap: ${s.phaseOverlap},
};

function splitText(text: string) {
  const words: string[] = [];
  let current = '';
  for (const char of Array.from(text)) {
    if (char === ' ') {
      if (current) words.push(current);
      words.push(' ');
      current = '';
    } else {
      current += char;
    }
  }
  if (current) words.push(current);
  return words;
}

export function TitleMotion({
  text = CONFIG.text,
  className = '',
  style = {},
  play = true,
  onComplete,
}: TitleMotionProps) {
  const words = useMemo(() => splitText(text), [text]);
  const [key, setKey] = useState(0);

  useEffect(() => {
    if (play) setKey(k => k + 1);
  }, [play]);

  const totalDuration = CONFIG.duration / 1000;
  const overlapFactor = UNDERLINE_CONFIG.phaseOverlap / 100;
  const underlineDuration = totalDuration * 0.5;
  const textStartDelay = underlineDuration * (1 - overlapFactor);

  const getWordVariants = (index: number) => ({
    hidden: { opacity: 0, y: 5 },
    visible: {
      opacity: 1, y: 0,
      transition: { duration: 0.3, delay: (CONFIG.delay / 1000) + textStartDelay + (index * CONFIG.stagger / 1000), ease: [0.4, 0, 0.2, 1] },
    },
  });

  const nonSpaceWords = words.filter(w => w !== ' ');
  const lastIndex = words.lastIndexOf(nonSpaceWords[nonSpaceWords.length - 1]);

  return (
    <span
      className={className}
      style={{
        display: 'inline-block',
        position: 'relative',
        fontFamily: CONFIG.fontFamily,
        fontWeight: CONFIG.fontWeight,
        letterSpacing: CONFIG.letterSpacing,
        lineHeight: CONFIG.lineHeight,
        textTransform: CONFIG.textTransform as any,
        ...style,
      }}
    >
      <span style={{ display: 'inline-flex', flexWrap: 'wrap' }}>
        {words.map((word, index) => {
          if (word === ' ') return <span key={\`\${key}-\${index}\`} style={{ display: 'inline-block', whiteSpace: 'pre' }}>{word}</span>;
          return (
            <motion.span
              key={\`\${key}-\${index}\`}
              variants={getWordVariants(index)}
              initial="hidden"
              animate={play ? 'visible' : 'hidden'}
              onAnimationComplete={index === lastIndex ? onComplete : undefined}
              style={{ display: 'inline-block' }}
            >
              {word}
            </motion.span>
          );
        })}
      </span>
      <motion.span
        key={\`underline-\${key}\`}
        initial={{ scaleX: 0, originX: 0 }}
        animate={play ? { scaleX: 1 } : { scaleX: 0 }}
        transition={{ duration: underlineDuration, delay: CONFIG.delay / 1000, ease: [0.4, 0, 0.2, 1] }}
        style={{
          position: 'absolute',
          left: 0,
          right: 0,
          bottom: '-0.1em',
          height: UNDERLINE_CONFIG.thickness,
          backgroundColor: UNDERLINE_CONFIG.underlineColor,
        }}
      />
    </span>
  );
}`;
}

function generateGlitchSliceCode(state: AppState): string {
  const s = state.glitchSlice;
  return `// Glitch slice preset settings
const GLITCH_CONFIG = {
  intensity: ${s.intensity},
  offsetAmount: ${s.offsetAmount},
  colorSeparation: ${s.colorSeparation},
};

export function TitleMotion({
  text = CONFIG.text,
  className = '',
  style = {},
  play = true,
  onComplete,
}: TitleMotionProps) {
  const [key, setKey] = useState(0);

  useEffect(() => {
    if (play) setKey(k => k + 1);
  }, [play]);

  const random = useMemo(() => createPRNG(CONFIG.seed), []);
  const glitchKeyframes = useMemo(() => {
    const frames = [];
    const numFrames = Math.floor(GLITCH_CONFIG.intensity * 8) + 2;
    for (let i = 0; i < numFrames; i++) {
      frames.push({ x: (random() - 0.5) * GLITCH_CONFIG.offsetAmount * 2 });
    }
    frames.push({ x: 0 });
    return frames;
  }, []);

  const duration = CONFIG.duration / 1000;
  const layerColors = GLITCH_CONFIG.colorSeparation
    ? ['rgba(255, 0, 0, 0.8)', 'rgba(0, 255, 0, 0.8)']
    : [];

  const mainVariants = {
    hidden: { opacity: 0, x: glitchKeyframes[0]?.x || 0 },
    visible: { opacity: 1, x: 0, transition: { duration, delay: CONFIG.delay / 1000, ease: [0.4, 0, 0.2, 1] } },
  };

  return (
    <span
      className={className}
      style={{
        display: 'inline-block',
        position: 'relative',
        fontFamily: CONFIG.fontFamily,
        fontWeight: CONFIG.fontWeight,
        letterSpacing: CONFIG.letterSpacing,
        lineHeight: CONFIG.lineHeight,
        textTransform: CONFIG.textTransform as any,
        ...style,
      }}
    >
      {GLITCH_CONFIG.colorSeparation && layerColors.map((color, i) => (
        <motion.span
          key={\`\${key}-layer-\${i}\`}
          initial={{ x: (i === 0 ? -1 : 1) * GLITCH_CONFIG.offsetAmount, opacity: 0.8 }}
          animate={play ? {
            x: [...glitchKeyframes.map(f => (i === 0 ? -1 : 1) * GLITCH_CONFIG.offsetAmount + f.x), 0],
            opacity: [...glitchKeyframes.map(() => 0.6), 0],
          } : { x: (i === 0 ? -1 : 1) * GLITCH_CONFIG.offsetAmount, opacity: 0.8 }}
          transition={{ duration: duration * 0.7, delay: CONFIG.delay / 1000 }}
          style={{ position: 'absolute', inset: 0, pointerEvents: 'none', color, mixBlendMode: 'screen' }}
          aria-hidden="true"
        >
          {text}
        </motion.span>
      ))}
      <motion.span
        key={key}
        variants={mainVariants}
        initial="hidden"
        animate={play ? 'visible' : 'hidden'}
        onAnimationComplete={onComplete}
        style={{ position: 'relative', display: 'inline-block' }}
      >
        {text}
      </motion.span>
    </span>
  );
}`;
}

function generateParticleBurstCode(state: AppState): string {
  const s = state.particleBurst;
  return `// Particle burst preset settings
const PARTICLE_CONFIG = {
  particleCount: ${s.particleCount},
  particleSize: ${s.particleSize},
  burstRadius: ${s.burstRadius},
  particleColor: ${JSON.stringify(s.particleColor)},
  fadeParticles: ${s.fadeParticles},
  burstDirection: ${JSON.stringify(s.burstDirection)},
};

interface Particle {
  id: number;
  angle: number;
  distance: number;
  size: number;
  delay: number;
}

export function TitleMotion({
  text = CONFIG.text,
  className = '',
  style = {},
  play = true,
  onComplete,
}: TitleMotionProps) {
  const chars = useMemo(() => Array.from(text), [text]);
  const [visibleChars, setVisibleChars] = useState<boolean[]>([]);
  const [particles, setParticles] = useState<Particle[][]>([]);
  const completedRef = useRef(0);
  const [key, setKey] = useState(0);

  useEffect(() => {
    if (!play) return;

    completedRef.current = 0;
    setKey(k => k + 1);
    setVisibleChars(new Array(chars.length).fill(false));

    const random = createPRNG(CONFIG.seed);
    const allParticles: Particle[][] = chars.map((char) => {
      if (char === ' ') return [];
      const charParticles: Particle[] = [];
      for (let i = 0; i < PARTICLE_CONFIG.particleCount; i++) {
        charParticles.push({
          id: i,
          angle: random() * Math.PI * 2,
          distance: PARTICLE_CONFIG.burstRadius * (0.3 + random() * 0.7),
          size: PARTICLE_CONFIG.particleSize * (0.5 + random() * 0.5),
          delay: random() * 0.2,
        });
      }
      return charParticles;
    });
    setParticles(allParticles);

    const revealTimeouts: NodeJS.Timeout[] = [];
    chars.forEach((_, index) => {
      const timeout = setTimeout(() => {
        setVisibleChars(prev => {
          const newState = [...prev];
          newState[index] = true;
          return newState;
        });
      }, CONFIG.delay + index * CONFIG.stagger);
      revealTimeouts.push(timeout);
    });

    return () => revealTimeouts.forEach(clearTimeout);
  }, [play, text, chars]);

  const duration = CONFIG.duration / 1000;

  const handleCharComplete = () => {
    completedRef.current++;
    if (completedRef.current === chars.filter(c => c !== ' ').length) {
      setTimeout(() => onComplete?.(), 100);
    }
  };

  return (
    <span
      className={className}
      style={{
        display: 'inline-flex',
        flexWrap: 'wrap',
        position: 'relative',
        fontFamily: CONFIG.fontFamily,
        fontWeight: CONFIG.fontWeight,
        letterSpacing: CONFIG.letterSpacing,
        lineHeight: CONFIG.lineHeight,
        textTransform: CONFIG.textTransform as any,
        ...style,
      }}
    >
      {chars.map((char, index) => {
        if (char === ' ') {
          return <span key={\`\${key}-\${index}\`} style={{ display: 'inline-block', width: '0.25em' }}>&nbsp;</span>;
        }

        const charParticles = particles[index] || [];
        const isVisible = visibleChars[index];
        const isInward = PARTICLE_CONFIG.burstDirection === 'inward';

        return (
          <span key={\`\${key}-\${index}\`} style={{ display: 'inline-block', position: 'relative' }}>
            <AnimatePresence>
              {isVisible && charParticles.map((particle) => {
                const x = Math.cos(particle.angle) * particle.distance;
                const y = Math.sin(particle.angle) * particle.distance;

                return (
                  <motion.span
                    key={\`particle-\${particle.id}\`}
                    style={{
                      position: 'absolute',
                      left: '50%',
                      top: '50%',
                      width: particle.size,
                      height: particle.size,
                      marginLeft: -particle.size / 2,
                      marginTop: -particle.size / 2,
                      borderRadius: '50%',
                      backgroundColor: PARTICLE_CONFIG.particleColor,
                      pointerEvents: 'none',
                    }}
                    initial={{
                      opacity: PARTICLE_CONFIG.fadeParticles ? 1 : 1,
                      scale: isInward ? 1 : 0,
                      x: isInward ? x : 0,
                      y: isInward ? y : 0,
                    }}
                    animate={{
                      opacity: PARTICLE_CONFIG.fadeParticles ? 0 : 1,
                      scale: isInward ? 0 : 1,
                      x: isInward ? 0 : x,
                      y: isInward ? 0 : y,
                    }}
                    exit={{ opacity: 0 }}
                    transition={{
                      duration: duration * 0.6,
                      delay: particle.delay,
                      ease: 'easeOut',
                    }}
                  />
                );
              })}
            </AnimatePresence>

            <motion.span
              style={{ display: 'inline-block', position: 'relative', zIndex: 10 }}
              initial={{ opacity: 0, scale: 0.5 }}
              animate={isVisible ? { opacity: 1, scale: 1 } : { opacity: 0, scale: 0.5 }}
              transition={{ duration: duration * 0.3, ease: [0, 0, 0.2, 1] }}
              onAnimationComplete={() => isVisible && handleCharComplete()}
            >
              {char}
            </motion.span>
          </span>
        );
      })}
    </span>
  );
}`;
}

function generateSparkleTrailCode(state: AppState): string {
  const s = state.sparkleTrail;
  return `// Sparkle trail preset settings
const SPARKLE_CONFIG = {
  sparkleCount: ${s.sparkleCount},
  sparkleSize: ${s.sparkleSize},
  trailLength: ${s.trailLength},
  sparkleColor: ${JSON.stringify(s.sparkleColor)},
  randomColors: ${s.randomColors},
  twinkle: ${s.twinkle},
};

const SPARKLE_COLORS = ['#fbbf24', '#f472b6', '#60a5fa', '#34d399', '#a78bfa', '#fb7185', '#fcd34d'];

interface Sparkle {
  id: number;
  x: number;
  y: number;
  size: number;
  color: string;
  delay: number;
  twinkleDelay: number;
}

const StarSparkle = ({ size, color }: { size: number; color: string }) => (
  <svg width={size} height={size} viewBox="0 0 24 24" fill={color}>
    <path d="M12 0L14.59 8.41L23 11L14.59 13.59L12 22L9.41 13.59L1 11L9.41 8.41L12 0Z" />
  </svg>
);

export function TitleMotion({
  text = CONFIG.text,
  className = '',
  style = {},
  play = true,
  onComplete,
}: TitleMotionProps) {
  const chars = useMemo(() => Array.from(text), [text]);
  const [visibleChars, setVisibleChars] = useState<boolean[]>([]);
  const [sparkles, setSparkles] = useState<Sparkle[][]>([]);
  const completedRef = useRef(0);
  const [key, setKey] = useState(0);

  useEffect(() => {
    if (!play) return;

    completedRef.current = 0;
    setKey(k => k + 1);
    setVisibleChars(new Array(chars.length).fill(false));

    const random = createPRNG(CONFIG.seed);
    const allSparkles: Sparkle[][] = chars.map((char) => {
      if (char === ' ') return [];
      const charSparkles: Sparkle[] = [];
      for (let i = 0; i < SPARKLE_CONFIG.sparkleCount; i++) {
        const x = (random() - 0.5) * 40;
        const y = (random() - 0.5) * 30;
        const color = SPARKLE_CONFIG.randomColors
          ? SPARKLE_COLORS[Math.floor(random() * SPARKLE_COLORS.length)]
          : SPARKLE_CONFIG.sparkleColor;
        charSparkles.push({
          id: i,
          x,
          y,
          size: SPARKLE_CONFIG.sparkleSize * (0.5 + random() * 0.5),
          color,
          delay: (i / SPARKLE_CONFIG.sparkleCount) * 0.3,
          twinkleDelay: random() * 0.5,
        });
      }
      return charSparkles;
    });
    setSparkles(allSparkles);

    const revealTimeouts: NodeJS.Timeout[] = [];
    chars.forEach((_, index) => {
      const timeout = setTimeout(() => {
        setVisibleChars(prev => {
          const newState = [...prev];
          newState[index] = true;
          return newState;
        });
      }, CONFIG.delay + index * CONFIG.stagger);
      revealTimeouts.push(timeout);
    });

    return () => revealTimeouts.forEach(clearTimeout);
  }, [play, text, chars]);

  const duration = CONFIG.duration / 1000;

  const handleCharComplete = () => {
    completedRef.current++;
    if (completedRef.current === chars.filter(c => c !== ' ').length) {
      setTimeout(() => onComplete?.(), 100);
    }
  };

  return (
    <span
      className={className}
      style={{
        display: 'inline-flex',
        flexWrap: 'wrap',
        position: 'relative',
        fontFamily: CONFIG.fontFamily,
        fontWeight: CONFIG.fontWeight,
        letterSpacing: CONFIG.letterSpacing,
        lineHeight: CONFIG.lineHeight,
        textTransform: CONFIG.textTransform as any,
        ...style,
      }}
    >
      {chars.map((char, index) => {
        if (char === ' ') {
          return <span key={\`\${key}-\${index}\`} style={{ display: 'inline-block', width: '0.25em' }}>&nbsp;</span>;
        }

        const charSparkles = sparkles[index] || [];
        const isVisible = visibleChars[index];

        return (
          <span key={\`\${key}-\${index}\`} style={{ display: 'inline-block', position: 'relative' }}>
            <AnimatePresence>
              {isVisible && charSparkles.map((sparkle) => (
                <motion.span
                  key={\`sparkle-\${sparkle.id}\`}
                  style={{
                    position: 'absolute',
                    left: '50%',
                    top: '50%',
                    marginLeft: sparkle.x - sparkle.size / 2,
                    marginTop: sparkle.y - sparkle.size / 2,
                    pointerEvents: 'none',
                  }}
                  initial={{ opacity: 0, scale: 0, rotate: 0 }}
                  animate={{
                    opacity: SPARKLE_CONFIG.twinkle ? [0, 1, 0.5, 1, 0.3, 1, 0] : [0, 1, 1, 0],
                    scale: [0, 1.2, 1, 1.1, 1, 0.8, 0],
                    rotate: [0, 180, 360],
                  }}
                  transition={{
                    duration: duration * SPARKLE_CONFIG.trailLength * 0.5,
                    delay: sparkle.delay + sparkle.twinkleDelay,
                    ease: 'easeInOut',
                  }}
                >
                  <StarSparkle size={sparkle.size} color={sparkle.color} />
                </motion.span>
              ))}
            </AnimatePresence>

            <motion.span
              style={{ display: 'inline-block', position: 'relative', zIndex: 10 }}
              initial={{ opacity: 0, y: 10, filter: 'brightness(1)' }}
              animate={isVisible ? {
                opacity: 1,
                y: 0,
                filter: ['brightness(1)', 'brightness(1.3)', 'brightness(1)'],
              } : { opacity: 0, y: 10 }}
              transition={{ duration: duration * 0.4, ease: [0, 0, 0.2, 1] }}
              onAnimationComplete={() => isVisible && handleCharComplete()}
            >
              {char}
            </motion.span>
          </span>
        );
      })}
    </span>
  );
}`;
}
